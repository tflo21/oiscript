const express = require('express');
const cors = require('cors');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 3001;

// Enable CORS for React frontend
app.use(cors());

// Use body-parser to parse JSON bodies
app.use(express.json());

// Serve static files from the React build folder
app.use(express.static(path.join(__dirname, 'frontend/build')));

// In-memory store for expected moves (you might want to use a database in production)
const expectedMoves = {
  SPY: 1.00,  // Default value
  QQQ: 1.00,
  DIA: 1.00
};

// API endpoint to get expected moves
app.get('/api/expected-moves', (req, res) => {
  res.json(expectedMoves);
});

// API endpoint to update expected move for a specific ticker
app.post('/api/expected-moves/:ticker', (req, res) => {
  const ticker = req.params.ticker.toUpperCase();
  const { expectedMove } = req.body;

  // Validate input
  if (!['SPY', 'QQQ', 'DIA'].includes(ticker)) {
    return res.status(400).json({ error: 'Invalid ticker symbol' });
  }

  if (typeof expectedMove !== 'number' || expectedMove < 0) {
    return res.status(400).json({ error: 'Invalid expected move value' });
  }

  // Update the expected move
  expectedMoves[ticker] = expectedMove;

  res.json({
    ticker,
    expectedMove: expectedMoves[ticker]
  });
});

// API endpoint to get options data for a specific ticker
app.get('/api/options/:ticker', (req, res) => {
  try {
    const ticker = req.params.ticker.toUpperCase();
    const validTickers = ['SPY', 'QQQ', 'DIA'];
    
    if (!validTickers.includes(ticker)) {
      return res.status(400).json({ error: 'Invalid ticker symbol' });
    }
    
    // Try to read from the JSON file generated by displayTopCallAndPutStrikes
    const jsonPath = path.join(__dirname, `${ticker.toLowerCase()}_top_strikes.json`);
    console.log(`Looking for JSON file: ${jsonPath}`);
    
    // Get the custom expected move from our in-memory store
    const customExpectedMove = expectedMoves[ticker];
    
    if (fs.existsSync(jsonPath)) {
      console.log(`JSON file found for ${ticker}`);
      const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
      
      // Log the data from the JSON file to see what we're working with
      console.log(`Raw JSON data for ${ticker}:`, {
        markPrice: jsonData.markPrice,
        exactMarkPrice: jsonData.exactMarkPrice
      });
      
      // Format the data for the chart, passing the custom expected move
      const formattedData = formatDataForChart(jsonData, customExpectedMove);
      
      // Log the formatted data to see what we're returning
      console.log(`Formatted data for ${ticker}:`, {
        markPrice: formattedData.markPrice,
        exactMarkPrice: formattedData.exactMarkPrice
      });
      
      return res.json(formattedData);
    }
    
    // If JSON file not found, log and return mock data
    console.log(`JSON file not found for ${ticker}, using mock data`);
    const mockData = createMockData(ticker);
    const formattedMockData = formatDataForChart(mockData, customExpectedMove);
    res.json(formattedMockData);
  } catch (error) {
    console.error(`Error processing data for ${req.params.ticker}:`, error);
    res.status(500).json({ error: 'Failed to process options data' });
  }
});

// API endpoint to get all tickers data
app.get('/api/options', async (req, res) => {
  try {
    const tickers = ['SPY', 'QQQ', 'DIA'];
    const result = {};
    
    for (const ticker of tickers) {
      // Try to read from JSON file
      const jsonPath = path.join(__dirname, `${ticker.toLowerCase()}_top_strikes.json`);
      console.log(`Looking for JSON file: ${jsonPath}`);
      
      // Get the custom expected move from our in-memory store
      const customExpectedMove = expectedMoves[ticker];
      
      if (fs.existsSync(jsonPath)) {
        console.log(`JSON file found for ${ticker}`);
        const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
        
        // Log the data from the JSON file
        console.log(`Raw JSON data for ${ticker}:`, {
          markPrice: jsonData.markPrice,
          exactMarkPrice: jsonData.exactMarkPrice
        });
        
        result[ticker] = formatDataForChart(jsonData, customExpectedMove);
        
        // Log the formatted data
        console.log(`Formatted data for ${ticker}:`, {
          markPrice: result[ticker].markPrice,
          exactMarkPrice: result[ticker].exactMarkPrice
        });
      } else {
        // If JSON file not found, use mock data
        console.log(`JSON file not found for ${ticker}, using mock data`);
        const mockData = createMockData(ticker);
        result[ticker] = formatDataForChart(mockData, customExpectedMove);
      }
    }
    
    res.json(result);
  } catch (error) {
    console.error('Error getting options data:', error);
    res.status(500).json({ error: 'Failed to fetch options data' });
  }
});

// Format the JSON data for the chart
function formatDataForChart(jsonData, customExpectedMove = null) {
  const { ticker, markPrice, topCalls, topPuts, allStrikes, summary } = jsonData;
  
  // Store the exact mark price from the original response
  const exactMarkPrice = jsonData.exactMarkPrice || markPrice;
  console.log(`In formatDataForChart, extracting exactMarkPrice: ${exactMarkPrice}`);
  
  // Calculate EM values using the direct input value from frontend
  // If customExpectedMove is provided, use it directly as the dollar amount for the expected move
  // Otherwise fall back to a default calculation
  let plusEM, minusEM;
  
  if (customExpectedMove !== null) {
    // Use the direct dollar value from user input
    plusEM = exactMarkPrice + customExpectedMove;
    minusEM = exactMarkPrice - customExpectedMove;
    console.log(`Using direct input EM value: $${customExpectedMove}`);
  }
  
  // Round to 2 decimal places for display
  plusEM = plusEM.toFixed(2)
  minusEM = minusEM.toFixed(2)
  
  console.log(`EM calculation result: +EM ${plusEM}, -EM ${minusEM}`);
  
  return {
    [ticker]: allStrikes,
    topCalls: topCalls,
    topPuts: topPuts,
    markPrice,
    exactMarkPrice,
    plusEM,
    minusEM,
    summary
  };
}

// Create mock data for testing
function createMockData(ticker) {
  const mockPrices = { SPY: 562, QQQ: 480, DIA: 425 };
  const markPrice = mockPrices[ticker] || 450;
  const exactMarkPrice = markPrice + 0.06; // Add decimal precision to mock data
  console.log(`Creating mock data with exactMarkPrice: ${exactMarkPrice}`);
  
  const allStrikes = [];
  const topCalls = [];
  const topPuts = [];
  
  // Generate all strikes data
  for (let i = -10; i <= 10; i++) {
    const strike = markPrice + i;
    const callOI = Math.round(Math.random() * 10000) * (i > 0 ? 1.2 : 0.8);
    const putOI = Math.round(Math.random() * 10000) * (i < 0 ? 1.2 : 0.8);
    
    allStrikes.push({
      strike,
      callOI,
      putOI
    });
    
    // Add to top calls if above mark price
    if (i > 0) {
      topCalls.push({
        strike,
        callOI
      });
    }
    
    // Add to top puts if below mark price
    if (i < 0) {
      topPuts.push({
        strike,
        putOI
      });
    }
  }
  
  // Sort and limit to top 8
  topCalls.sort((a, b) => b.callOI - a.callOI).splice(8);
  topPuts.sort((a, b) => b.putOI - a.putOI).splice(8);
  
  // Sort by strike price (descending for calls, ascending for puts)
  topCalls.sort((a, b) => b.strike - a.strike);
  topPuts.sort((a, b) => a.strike - b.strike);
  
  // Calculate expected market move
  const expectedMovePercent = 0.01;
  const plusEM = Math.round((markPrice * (1 + expectedMovePercent)) * 100) / 100;
  const minusEM = Math.round((markPrice * (1 - expectedMovePercent)) * 100) / 100;
  
  // Calculate totals
  const totalCallOI = allStrikes.reduce((sum, item) => sum + item.callOI, 0);
  const totalPutOI = allStrikes.reduce((sum, item) => sum + item.putOI, 0);
  const putCallRatio = totalCallOI > 0 ? totalPutOI / totalCallOI : 0;
  
  return {
    ticker,
    topCalls,
    topPuts,
    markPrice,
    exactMarkPrice,
    plusEM,
    minusEM,
    summary: {
      totalCallOI,
      totalPutOI
    }
  };
}

// Serve React app for any other routes
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'frontend/build', 'index.html'));
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Visit http://localhost:${PORT} to view the app`);
});